%%%%%%% Global Variables %%%%%%

% no. of servers
map MaxServer: Nat;
eqn MaxServer = 1;

% max no. of client requests
map MaxClientRequest: Pos;
eqn MaxClientRequest = 1;

%max no. of terms
map MaxTerm: Pos;
eqn MaxTerm = 1;

% no. that defines the majority within the cluster 
% we don't model changes in cluster membership so this no. remains constant
map MAJORITY: Pos;
eqn MAJORITY = 1;

%%%%% Data Types %%%%%

% possible states of a node
sort NodeState = struct Leader | Candidate | Follower;

% possible types of message
sort mType = struct MTreqVote | MTreqVoteResponse | MTappendEntriesReq | MTappendEntriesResponse;

% structure for different kinds of messages
sort RPC = struct RequestVote(currentTerm: Nat, lastLogIndex: Nat, lastLogTerm: Nat) | ResponseVote(currentTerm: Nat, isVoteGranted: Bool) | 
        AppendEntriesReq(currentTerm: Nat, prevLogIndex: Nat, prevLogTerm: Nat, entries: entryList, leaderCommit: Nat) | 
        AppendEntriesResponse(currentTerm: Nat, success: Bool, matchIndex: Nat);

% entry (command) inside the log
sort logCommand = struct Command(term: Nat, commandID: Nat);

% log maitained on each node (list of commands)
sort entryList = List(logCommand);

%%%%%%% Functions (Equations) %%%%%%%

% gets the term of the last command in the log
map lastTerm: entryList -> Nat;
var log: entryList;
eqn (# log == 0) -> lastTerm(log) = 0;
    (# log != 0) -> lastTerm(log) = term(rhead(log));

% get term of a particular index of the log
% term of index 0 is 0 because log is one-indexed 
map getTerm: entryList # Nat -> Nat;
var log: entryList;
    index: Nat;
eqn (index > 0) -> getTerm(log, index) = term(log . index);
    (index == 0) -> getTerm(log, index) = 0;

% slice a log (inclusive of first and last)
map listSlice: entryList # entryList # Nat # Nat -> entryList;
var log, slice: entryList;
    first, last: Nat; 
eqn (first == 0) -> listSlice(log, slice, first, last) = listSlice(log, slice, 1, last);
    (first == min(last, # log)) -> listSlice(log, slice, first, last) = slice <| (log . min(last, # log));
    (first < min(last, # log)) ->  listSlice(log, slice, first, last) = listSlice(log, slice <| (log . first), first + 1, min(last, # log));
    (first > min(last, # log)) -> listSlice(log, slice, first, last) = [];

% slice a list of naturals (inclusive of first and last)
map listSliceNat: List(Nat) # List(Nat) # Nat # Nat -> List(Nat);
var list, slicedList: List(Nat);
    firstElement, lastElement: Nat; 
eqn (firstElement == lastElement) -> listSliceNat(list, slicedList, firstElement, lastElement) = slicedList <| (list . lastElement);
    (firstElement != lastElement) ->  listSliceNat(list, slicedList, firstElement, lastElement) = listSliceNat(list, slicedList <| (list . firstElement), firstElement + 1, lastElement);

% return the no. of servers that have a particular entry at the given index
% Param 1: Index of the entry
% Param 2: No. of servers that have the entry replicated (by default = 1 because the leader always has this entry in their log)
% Param 3: loop counter that goes from 0 to max server id
% Param 4: match index array which stores for each server, index of highest log entry replicated on the server
map MajorityAgree: Nat # Nat # Nat # List(Nat) -> Nat;
var index, agreementNo, loopCounter: Nat;
    array: List(Nat);
eqn (loopCounter == MaxServer) -> MajorityAgree(index, agreementNo, loopCounter, array) = agreementNo;
    (index <= array . loopCounter) -> MajorityAgree(index, agreementNo, loopCounter, array)  = MajorityAgree(index, agreementNo + 1, loopCounter + 1, array);
    (index > array . loopCounter) -> MajorityAgree(index, agreementNo, loopCounter, array)  = MajorityAgree(index, agreementNo, loopCounter + 1, array);  

% returns the highest index for which a log entry has been replicated on a majority of servers
% Param 1: length of log
% Param 2: match index array which stores for each server, index of highest log entry replicated on the server
map MaxAgreeIndex: Nat # List(Nat) -> Nat;
var lenLog: Nat;
    array: List(Nat);
eqn (lenLog == 0) -> MaxAgreeIndex(lenLog, array) = 0;
    (MajorityAgree(lenLog, 1, 0, array) >= MAJORITY) -> MaxAgreeIndex(lenLog, array) = lenLog;
    (MajorityAgree(lenLog, 1, 0, array) < MAJORITY) -> MaxAgreeIndex(lenLog, array) = MaxAgreeIndex(Int2Nat(lenLog - 1), array);

% add an element to a list if it isn't already in there. If it is, return the same list
map add: List(Nat) # Nat -> List(Nat);
var listVotes: List(Nat);
    voter: Nat;
eqn (voter in listVotes) -> add(listVotes, voter) = listVotes;
    (!(voter in listVotes)) -> add(listVotes, voter) = listVotes <| voter;

%CHANGE THIS ACCORDING TO NUMBER OF SERVERS
% returns an array with num times the no. of servers
map initArray: Nat -> List(Nat);
var num: Nat;
eqn initArray(num) = [num];

% return the length of the log (# log - 1) because log is 1-indexed
map lengthLog: entryList -> Nat;
var log: entryList;
eqn lengthLog(log) = Int2Nat(# log -1); 

%%%%% Actions %%%%%%%%

% client interaction
% Param 1: Command Id (Id of the command client sends)
% Param 2: Receiver Id (Id of server that is supposed to receive the message)
act sendClientRequest, recvClientRequest, clientCommand: Pos # Nat;

% Send & Receive RPCs
% Param 1: Receiver Id (Id of server that is supposed to receive the message)
% Param 2: The RPC message
% Param 3: Type of message being sent
% Param 4; Sender Id (Id of server that sends the message)

act sendAppendEntriesRequest, receiveAppendEntriesRequest, appendEntryRequest, sendAppendEntriesResponse, receiveAppendEntriesResponse, appendEntryResponse, sendRequestVoteRequest, receiveRequestVote, RequestVoteMulti, sendRequestVoteResponse, receiveRequestVoteResponse, VoteResponse: Nat # RPC # mType # Nat;

% simple actions (required to prevent unguarded recursion)
act advanceCommitIndex, leaderTransition, candidateTransition;

% votedFor has special value -1 if the node hasn't voted for anyone
proc Node(id: Nat, currentState: NodeState, currentTermNode: Nat, log: entryList, commitIndex: Nat,
          votedFor: Int, votesGranted: List(Nat), nextIndex: List(Nat), matchingIndex: List(Nat)) = 
     % Leader can receive messages from a client or broadcast messages to other nodes
     (currentState == Leader) -> (
          % receive messages from clients
          (sum clientCommandID: Pos, msgID: Nat . ( (id == msgID) -> recvClientRequest(clientCommandID, msgID)) . Node(log = log <| Command(currentTermNode, clientCommandID)))
          +
          % send append entry requests to clients
          (sum receiverID: Nat . ( ((receiverID != id) && (receiverID < MaxServer)) -> 
                    (sendAppendEntriesRequest(receiverID, AppendEntriesReq(currentTermNode, Int2Nat((nextIndex . receiverID) - 1), getTerm(log, Int2Nat((nextIndex . receiverID) - 1)), listSlice(log, [], nextIndex . receiverID, min(#log, nextIndex . receiverID)), commitIndex), MTappendEntriesReq, id)) 
               )
          ) . Node()
          +
          %receive responses for append entry messages
          (sum senderID, receiverID: Nat, appendEntryRes: RPC, msgType: mType . ( ((senderID != id) && (senderID < MaxServer) && (msgType == MTappendEntriesResponse) && (receiverID == id)) ->
                    receiveAppendEntriesResponse(receiverID, appendEntryRes, msgType, senderID) . (
                         % drop stale message
                         (currentTerm(appendEntryRes) < currentTermNode) -> Node()   
                         +
                         (currentTerm(appendEntryRes) > currentTermNode) -> Node(currentTermNode = currentTerm(appendEntryRes), currentState = Follower, votedFor = -1)
                         +
                         (currentTerm(appendEntryRes) == currentTermNode) -> (
                              (success(appendEntryRes)) -> Node(nextIndex = (listSliceNat(nextIndex, [], 0, Int2Nat(senderID-1)) ++ [matchIndex(appendEntryRes) + 1] ++ listSliceNat(nextIndex, [], (senderID+1), Int2Nat(# nextIndex-1))), matchingIndex = (listSliceNat(matchingIndex, [], 0, Int2Nat(senderID-1)) ++ [matchIndex(appendEntryRes)] ++ listSliceNat(matchingIndex, [], (senderID+1), Int2Nat(# matchingIndex-1))))
                              <>
                              Node()
                         )
                    )
               )
          )
          +
          % advance commit index
          ((MaxAgreeIndex(# log, matchingIndex) > 0) && (getTerm(log, MaxAgreeIndex(# log, matchingIndex)) == currentTermNode)) -> advanceCommitIndex . Node(commitIndex = MaxAgreeIndex(# log, matchingIndex))  
     )
     +
     %Followers can transition into a candidate states and handle vote requests
     ((currentState == Follower) && (currentTermNode < MaxTerm)) -> (
          candidateTransition . Node(currentState = Candidate, currentTermNode = currentTermNode + 1, votedFor = Nat2Int(id), votesGranted = [id])
     )
     +
     % Candidates can request votes or handle vote responses
     (currentState == Candidate) -> (
          % send request vote RPCs
          (sum receiverID: Nat . (((receiverID != id) && (receiverID < MaxServer)) -> 
                    (sendRequestVoteRequest(receiverID, RequestVote(currentTermNode, # log, getTerm(log, Int2Nat(# log - 1))), MTreqVote, id))
               )
          )
         +
          % receive request vote responses 
          (sum senderID, receiverID: Nat, voteRequestResponse: RPC, msgType: mType . ( ((senderID != id) && (senderID < MaxServer) && (msgType == MTreqVoteResponse) && (receiverID == id)) ->
                    receiveRequestVoteResponse(receiverID, voteRequestResponse, msgType, senderID) . (
                         % drop stale message
                         (currentTerm(voteRequestResponse) < currentTermNode) -> Node()
                         +
                         % update term if term is higher
                         (currentTerm(voteRequestResponse) > currentTermNode) -> Node(currentTermNode = currentTerm(voteRequestResponse), currentState = Follower, votedFor = -1)
                         +
                         (currentTerm(voteRequestResponse) == currentTermNode) -> 
                              (isVoteGranted(voteRequestResponse)) -> Node(votesGranted = add(votesGranted, senderID)) 
                    )
               )
          )
          +
          % become leader if majority votes
          (# votesGranted >= MAJORITY) -> leaderTransition . Node(currentState = Leader, nextIndex = initArray(# log + 1), matchingIndex = initArray(0))
     )
     % things all states can do
     +
     % receive request vote request RPCs
     (sum senderID, receiverID: Nat, voteRequest: RPC, msgType: mType . ( ((senderID != id) && (senderID < MaxServer) && (msgType == MTreqVote) && (receiverID == id)) ->
               receiveRequestVote(receiverID, voteRequest, msgType, senderID) . (
                    % discard message if the term is older
                    (currentTerm(voteRequest) < currentTermNode) -> Node()
                    +
                    (                    
                         (currentTerm(voteRequest) == currentTermNode) -> 
                                   % check for validity of the log
                                   (lastLogTerm(voteRequest) >= getTerm(log, Int2Nat(# log - 1))) -> 
                                        % vote for the server if we haven't voted for anything or already voted for it
                                        (votedFor == -1 || votedFor == receiverID) -> sendRequestVoteResponse(senderID, ResponseVote(currentTermNode, true), MTreqVoteResponse, id) . Node(votedFor = senderID)
                              % reject otherwise
                                        <>
                                        sendRequestVoteResponse(senderID, ResponseVote(currentTermNode, false), MTreqVoteResponse, id) . Node()
                                   <>
                                   sendRequestVoteResponse(senderID, ResponseVote(currentTermNode, false), MTreqVoteResponse, id) . Node()
                    )
                    +
                    (                    
                         (currentTerm(voteRequest) > currentTermNode) -> 
                                   % check for validity of the log
                                   (lastLogTerm(voteRequest) >= getTerm(log, Int2Nat(# log - 1))) -> 
                                        % we don't check if we haven't voted for anything or already voted for it because when we update term we automatically set votedFor to nil
                                        sendRequestVoteResponse(senderID, ResponseVote(currentTerm(voteRequest), true), MTreqVoteResponse, id) . Node(currentTermNode = currentTerm(voteRequest), currentState = Follower, votedFor = senderID)
                                   % reject otherwise & become follower
                                   <>
                                   sendRequestVoteResponse(senderID, ResponseVote(currentTerm(voteRequest), false), MTreqVoteResponse, id) . Node(currentTermNode = currentTerm(voteRequest), currentState = Follower, votedFor = -1)
                    )
               )
          )
     )
     +
     % handle append entries request or heartbeat
     (sum senderID, receiverID: Nat, appendEntry: RPC, msgType: mType . ( ((senderID != id) && (senderID < MaxServer) && (msgType == MTappendEntriesReq) && (receiverID == id)) ->
               receiveAppendEntriesRequest(receiverID, appendEntry, msgType, senderID) . (
                     % discard message if the term is older
                    (currentTerm(appendEntry) < currentTermNode) -> Node()
                    +
                    (
                         (currentTerm(appendEntry) == currentTermNode) -> 
                              % check if log is ok
                              ((prevLogIndex(appendEntry) == 0) || ((prevLogIndex(appendEntry) > 0) && (prevLogIndex(appendEntry) <= # log) && (prevLogTerm(appendEntry) == (getTerm(log,prevLogIndex(appendEntry)))))) ->
                                   % heartbeat message
                                   (# entries(appendEntry) == 0) -> sendAppendEntriesResponse(senderID, AppendEntriesResponse(currentTermNode, true, prevLogIndex(appendEntry)), MTappendEntriesResponse, id) . Node(commitIndex = leaderCommit(appendEntry))
                                   <>
                                        (    % check for conflict with leader
                                             ((# log >= (prevLogIndex(appendEntry)+1)) && (getTerm(log, (prevLogIndex(appendEntry)+1)) != term(entries(appendEntry) . 0))) ->
                                                  (# listSlice(log, [], 1, prevLogIndex(appendEntry)) == prevLogIndex(appendEntry)) -> sendAppendEntriesResponse(senderID, AppendEntriesResponse(currentTermNode, true, prevLogIndex(appendEntry) + 1), MTappendEntriesResponse, id) . Node(log = listSlice(log, [], 1, prevLogIndex(appendEntry)) ++ entries(appendEntry), commitIndex = leaderCommit(appendEntry))
                                                  <>
                                                  sendAppendEntriesResponse(senderID, AppendEntriesResponse(currentTermNode, true, prevLogIndex(appendEntry) + 1), MTappendEntriesResponse, id) . Node(log = listSlice(log, [], 1, prevLogIndex(appendEntry)), commitIndex = leaderCommit(appendEntry))
                                             <>
                                             sendAppendEntriesResponse(senderID, AppendEntriesResponse(currentTermNode, true, prevLogIndex(appendEntry) + 1), MTappendEntriesResponse, id) . Node(commitIndex = leaderCommit(appendEntry))
                                        )
                              % log is not okay
                              <>
                              sendAppendEntriesResponse(senderID, AppendEntriesResponse(currentTermNode, false, 0), MTappendEntriesResponse, id) . Node()

                    )
                    +
                    %if the append entry request has higher term then update our term
                    (
                         (currentTerm(appendEntry) > currentTermNode) -> 
                              ((prevLogIndex(appendEntry) == 0) || ((prevLogIndex(appendEntry) > 0) && (prevLogIndex(appendEntry) <= # log) && (prevLogTerm(appendEntry) == (getTerm(log,prevLogIndex(appendEntry)))))) ->
                                   % heartbeat message
                                   (# entries(appendEntry) == 0) -> sendAppendEntriesResponse(senderID, AppendEntriesResponse(currentTerm(appendEntry), true, prevLogIndex(appendEntry)), MTappendEntriesResponse, id) . Node(currentTermNode = currentTerm(appendEntry), currentState = Follower, votedFor = -1, commitIndex = leaderCommit(appendEntry))
                                   <>
                                        (    % check for conflict with leader
                                             ((# log >= (prevLogIndex(appendEntry)+1)) && (getTerm(log, (prevLogIndex(appendEntry)+1)) !=  term(entries(appendEntry) . 0))) ->
                                                  (# listSlice(log, [], 1, prevLogIndex(appendEntry)) == prevLogIndex(appendEntry)) -> sendAppendEntriesResponse(senderID, AppendEntriesResponse(currentTerm(appendEntry), true, prevLogIndex(appendEntry) + 1), MTappendEntriesResponse, id) . Node(currentTermNode = currentTerm(appendEntry), currentState = Follower, votedFor = -1, log = listSlice(log, [], 1, prevLogIndex(appendEntry)) ++ entries(appendEntry), commitIndex = leaderCommit(appendEntry))
                                                  <>
                                                  sendAppendEntriesResponse(senderID, AppendEntriesResponse(currentTerm(appendEntry), true, prevLogIndex(appendEntry) + 1), MTappendEntriesResponse, id) . Node(currentTermNode = currentTerm(appendEntry), currentState = Follower, votedFor = -1, log = listSlice(log, [], 1, prevLogIndex(appendEntry)), commitIndex = leaderCommit(appendEntry))
                                             <>
                                             sendAppendEntriesResponse(senderID, AppendEntriesResponse(currentTerm(appendEntry), true, prevLogIndex(appendEntry) + 1), MTappendEntriesResponse, id) . Node(currentTermNode = currentTerm(appendEntry), currentState = Follower, votedFor = -1, commitIndex = leaderCommit(appendEntry))
                                        )
                              % log is not okay
                              <>
                              sendAppendEntriesResponse(senderID, AppendEntriesResponse(currentTerm(appendEntry), false, 0), MTappendEntriesResponse, id) . Node(currentTermNode = currentTerm(appendEntry), currentState = Follower, votedFor = -1)

                    )
               )
          )
     )
     ;

proc Client(clientCommandID: Pos) = 
     sum serverID: Nat . ((clientCommandID <= MaxClientRequest) -> sendClientRequest(clientCommandID, serverID) . Client(clientCommandID+1));

init allow( {appendEntryRequest, appendEntryResponse, RequestVoteMulti, VoteResponse, clientCommand},
               comm(
                    {
                         sendClientRequest | recvClientRequest -> clientCommand,
                         sendAppendEntriesRequest | receiveAppendEntriesRequest -> appendEntryRequest, 
                         sendAppendEntriesResponse | receiveAppendEntriesResponse -> appendEntryResponse, 
                         sendRequestVoteRequest | receiveRequestVote -> RequestVoteMulti, 
                         sendRequestVoteResponse | receiveRequestVoteResponse -> VoteResponse

                    },
                    hide( {advanceCommitIndex, leaderTransition, candidateTransition},
                         Client(1) || Node(id = 0, currentState = Follower, currentTermNode = 0, log = [Command(0,0)], commitIndex = 0,
          votedFor = -1, votesGranted = [], nextIndex = initArray(0), matchingIndex = initArray(0)))
               )

);